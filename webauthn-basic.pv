(* ProVerif Web Authentication Formal Model
   originally by Iness Ben Guirat and Harry Halpin
   Paper: https://dl.acm.org/doi/10.1145/3190619.3190640
   Slides: https://cps-vo.org/node/48511
   github: https://github.com/hhalpin/weauthn-model
*)

(**** webauthn-basic.pv ****

See the paper section 5.2 for a detailed description of this model.

In summary: This models first registration of a WebAuthn user credential with a server (aka Relying Party) and then subsequent authentication using that registered credential.  The model seeks to prove various properties of the protocol.

Updated by Jeff Hodges with corrections and comments, May 2021
http://kingsmountain.com/people/jeff.hodges/
****)


free c:channel.  (* TLS channel *)

type AttestationPublicKey.
type AttestationPrivatekey.

type nonce.

type pkey.    (* asymmetric public key *)
type skey.    (* asymmetric secret key *)

type RP_id.
type key.     (* symmetric key *)



(***** For Digital Signatures *****)
(*                                                            *)
(*  This model of signatures assumes that the signature is    *)
(*  always accompanied with the message x.                    *)

fun spk(skey):pkey.
fun sign(bitstring, skey):bitstring.

reduc forall x:bitstring, y:skey; getmess(sign(x, y)) = x. (* The destructor getmess allows
                                                              the attacker to get the message
                                                              x from the signature, even
                                                              without having the key. *)

reduc forall x:bitstring, y:skey; checksign(sign(x, y), spk(y)) = x. (* The destructor
                                                                        checksign checks the signature,
                                                                        and returns x only when the
                                                                        signature is correct. Honest
                                                                        processes typically use only
                                                                        checksign. *)


(***** For nonces *****)

fun nonce_to_bitstring ( nonce ) : bitstring [ data , typeConverter ] .
table nonceTable(nonce) .


(***** For Digital signature over Attestation Credentials *****)
(*                                                            *)
(*  This model of signatures assumes that the signature is    *)
(*  always accompanied with the message x.                    *)

fun spkAtt(AttestationPrivatekey): AttestationPublicKey.
fun signAtt(bitstring, AttestationPrivatekey): bitstring.

reduc forall x:bitstring, y:AttestationPrivatekey; getmessAtt(signAtt(x, y)) = x. (* The destructor getmess allows
                                                                                     the attacker to get the message
                                                                                     x from the signature, even
                                                                                     without having the key. *)

reduc forall x:bitstring, y:AttestationPrivatekey; checksignAtt(signAtt(x, y), spkAtt(y)) = x. (* The destructor
                                                                                    checksign checks the signature,
                                                                                    and returns x only when the
                                                                                    signature is correct. Honest
                                                                                    processes typically use only
                                                                                    checksign. *)

free attskU: AttestationPrivatekey [private].
free attpkU: AttestationPublicKey [private].

(* originally:
free attpkU: AttestationPrivatekey [private]. -- BUG?: should be type AttestationPublicKey ?
                                                 Corrected above *)



free k: key [private].  (* TLS symmetric encryption key *)



(***** Symetric encryption *****)

fun senc(bitstring, key): bitstring.
reduc forall x: bitstring, encryptKey: key; sdec(senc(x,encryptKey),encryptKey) = x.


(***** User's ID  and Server's ID *****)

(* const cookie:bitstring [private].         -- unused in the original model *)
const attestation_cert:bitstring [private].  (* in the original model this component does not appear to add
                                                any value to the analysis. *)
const a: RP_id [private].



(***** Events and Queries *****)

event sentChallengeResponse(bitstring, bitstring).
event validChallengeResponse(bitstring, bitstring).

(* we can only receive a valid response if the user sent a response message *)
query N:bitstring, s:bitstring; event(validChallengeResponse(N, s)) ==> event(sentChallengeResponse(N, s)).

(* query N:bitstring; event(reachAuthentication(N)).
event reachAuthentication(bitstring). *)

query attacker(attskU).
query attacker(attpkU).
query attacker(k).



(***** Processes *****)

let processUser ( k: key, attskU: AttestationPrivatekey, attpkU:AttestationPublicKey, attestation_cert:bitstring) =

    (* Registration *)

    in(c, s:bitstring);
    let (challengeU:nonce, a:RP_id) = sdec(s,k) in

    new skU: skey;          (* mint new user credential "secret key user" |skU| *)
    let pkU = spk(skU) in   (* and "public key user" |pkU|                      *)

    out(c,                  (* return attestation response                      *)
        senc( ( attestation_cert, signAtt( (pkU, attpkU, challengeU), attskU ) ), k)
       );


    (* Authentication *)

    in(c, s1:bitstring);
    let mess1 = sdec(s1, k) in  (* receive server's challenge. However, this analysis is lacking because
                                   it does not parse the server's message and then use the credential
                                   private key corresponding to the public key registered with a particular
                                   server. *)

    (* originally:
        event sentChallengeResponse( mess1, sign( senc(mess1,k), skU ) ); -- AFAICT, this and..
        out(c, sign(senc(mess1,k), skU)).     -- ..this are incorrectly constructed! The message needs to be enc'd
                                              -- using `k`, with the sig (by skU) inside.  (corrected below)
    *)

    event sentChallengeResponse( mess1, senc( sign(mess1, skU), k) );
    out(c,
        senc( sign(mess1, skU), k)
       ).



let processServer (k: key, a:RP_id) =

    (* Registration *)

    new challenge1:nonce;
    out(c, senc((challenge1, a), k));   (* send registration request *)
    in(c, s:bitstring);                 (* receive possible registration response *)

    let m = sdec(s,k) in
    let (cert:bitstring, pkY1: pkey, attpkU1:AttestationPublicKey, credUser: bitstring, Nt:nonce) = getmessAtt(m) in
                                            (* if the above succeeds, we received a registration response *)
    let ver = checksignAtt(m, attpkU1) in   (* verify signature on attestation response *)

    if (Nt=challenge1) then (  (* if we got here, then the signature on the registration response msg verified,
                                  and if the challenge returned matches the one we sent, then we will proceed
                                  to challenge the user to authenticate (not an actually typical server behavior,
                                  this just simplifies the model). *)

        (* Authentication *)

        new challenge2:nonce;
        let mess = nonce_to_bitstring( challenge2 ) in
        out(c, senc( (mess, a), k) );    (* authentication request with `challenge2` as `mess`   *)

        (****     for each of next 4 lines: local var | what client sent and thus local var is set to      *)
        (*                                ------------|----------------------------------------------      *)
        in(c, s2:bitstring);             (*     s2    |   senc( sign(mess1, skU), k )                      *)
        let m1 = sdec(s2, k) in          (*     m1    |   sign( mess1, skU )                               *)
        let m2 = checksign(m1, pkY1) in  (*     m2    |   mess1 (_should_ be `(mess,a)` if sig is valid)   *)
                                         (*           |                                                    *)
        let m3 = getmess(m1) in          (*     m3    |   mess1 (tho server sent `(mess,a)`) in out() above*)

        if ( m3 = m2 ) then (            (* This check is necessary (?) in order to determine if the       *)
                                         (* signed msg is actually the expected one.                       *)
                                         (* Perhaps should use for the preceding "let" and this "if":      *)
                                         (*           let (Nbitstr:bitstring, a1:RP_id) = getmess(m1) in   *)
                                         (*           if ((Nbitstr = mess) && (a1 = a)) then ( ... )   (?) *)
            event validChallengeResponse(m3, m2)
        )

        (* originally:
            in(c, s2:bitstring);
            let m1 = sdec(s2, k) in     -- this does not match how the (incorrectly written) client is
                                        -- constructing the msg to be rec'd here. (corrected above)
            let m2 = checksign(m1, pkY1) in
            let m3 = getmess(s2) in     -- this does match the client's (incorrect) construction (corrected above)
            if ( m3 = getmess(s2)) then (
                event validChallengeResponse(m3, s2)
            )
        *)
    )
    .


process
  new tlsKey: key; (* assume TLS handshake is error-free and yields this symmetric channel-encryption key *)
  new attSecretKey: AttestationPrivatekey; (* assume a particular authenticator with a particular attestation
                                              private key *)

  let attPublicKey = spkAtt(attSecretKey) in
  (
    !processUser(tlsKey, attSecretKey, attPublicKey, attestation_cert) | !processServer(tlsKey, a)
  )


(***** END *****)
